//wrap the series calculation function so that we can get the data
const _calcfunc = $.fn.reportCardBoxplotCalculateAllSeriesData

var options = {
    calculateAverage: true,
    horizontalGraphs: true,
    displayBoxPlotSummary: true //Depends on horizontalGraphs being true
}

/**
 * @typedef IReportCardSeriesData
 * @property {number[][]} allGraphData
 * @property {[]} allOutliers
 * @property {{info: null, uid: null, value: number}[][]} input
 */

$.fn.reportCardBoxplotCalculateAllSeriesData = function () {
    /**
     * @type {IReportCardSeriesData}
     */
    const result = _calcfunc.apply(this, arguments)
    //OPTION: Calculate average
    if(options.calculateAverage) {
        const averageScores = []
        for(let i = 0; i<=4; i++) {//for each of 5 figure summary
            let totalScores = 0
            let skippedAssessments = 0 //amount of skipped assessments

            //calculate sum of all scores for this figure
            result.allGraphData.forEach((assessment) => { //for each assessment
                if(assessment[0] === null && assessment[2] === null && assessment[4] === null) {
                    skippedAssessments++
                    return
                }
                totalScores += assessment[i]
            })
            averageScores.push(totalScores / (result.allGraphData.length - skippedAssessments))
        }
        result.allGraphData.push(averageScores) //push it into the result
    }
    handleResultsData(result)
    return result
}

//wrap the render as well to re-render the text on re render
const _renderfunc = $.fn.reportCardBoxplotRender

$.fn.reportCardBoxplotRender = function () {
    renderResultsData()
    //OPTION: Horizontal graphs
    if(options.horizontalGraphs) {
        //5 Figure summary depends on this option
        arguments[0].orientation = 'horizontal'
    }

    if(options.calculateAverage) {
        //OPTION: Calculate average
        
        arguments[0].allAssessments.push('Average') //Push a new assessment named Average
        arguments[0].additionalSeries[0].data.push(
            arguments[0].additionalSeries[0].data.reduce((partialSum, a) => partialSum + a, 0) / arguments[0].additionalSeries[0].data.filter(i => !!i).length
        )

        console.log(arguments)

    
        const additionalSeries = arguments[0].additionalSeries[0]
        // An array containing [assessment count] arrays, which contain 5 figure summary
        const allGraphData = arguments[0].allData.allGraphData
    
        //wrap the tooltip render function
        const _pointFormatter = arguments[0].additionalSeries[0].tooltip.pointFormatter
        arguments[0].additionalSeries[0].tooltip.pointFormatter = function() {
            if(this.x === additionalSeries.data.length - 1) { //if this.x(index) is the last one
                return  '<div style="width:200px!important;overflow:auto;white-space:normal !important;">' +
                `<div class="grade"><span>${additionalSeries.data[additionalSeries.data.length - 1].toFixed(2)}%</span></div>` +
                '<b>This is the average mark of all of your completed assessments generated by Schoolbox+</b>. The box plot takes the average of each 5 figure summaries.' +
                '</div>';
            } else {
                const [estimatedRank, fromRange, toRange] = estimateRanking(allGraphData[this.x], additionalSeries.data[this.x])
                return `
                <div style="width:200px!important;overflow:auto;white-space:normal !important;">
                    <b>
                        Schoolbox+ Rank Estimation
                    </b><br>
                    You are better than<br>
                    <span><span style="font-size: large;">${estimatedRank}%</span>, ${25*fromRange}% to ${25*toRange}%</span><br>
                    of students in this course.
                    <br>
                    <b>Your grade:</b>
                </div>
                ` +
                _pointFormatter.apply(this, arguments)
            }
        }
    }


    return _renderfunc.apply(this, arguments)
}

//Click the "Apply filters" button to trigger reload
document.querySelector('#submit_button').click()

function wait(time) {
    return new Promise((res, _) => {setTimeout(() => {res()}, time)})
}

let assessmentData = []

//Handle the results and render them
async function handleResultsData({ allGraphData }) {
    assessmentData = allGraphData
}

async function renderResultsData() {
    //OPTION: Display 5 figure summary
    if(options.displayBoxPlotSummary) {
    const foo = ['min', 'Q1', 'Q2', 'Q3', 'max']
    await wait(10)


        /**
         * @type {Element}
         */
        const elm = document.querySelector('g.highcharts-axis-labels.highcharts-xaxis-labels')
        assessmentData.forEach((assessment, assessmentIndex) => {
            
            assessment.forEach((number, numberIndex) => {
                //creating the spacing element(inside the loop because apparently you need a new instance or smth)
                const spacingElm = document.createElement('tspan')
                spacingElm.setAttribute('dy', '14')
                spacingElm.setAttribute('x', elm.children[assessmentIndex].getAttribute('x'))
                spacingElm.setAttribute('style', 'transform-origin: 0px 0px; white-space: inherit;')
                spacingElm.innerText = 'â€‹'
                //creating the text element
                const textElm = document.createTextNode(`|${Math.round(number)}`)
                //insent the element
                elm.children[assessmentIndex].appendChild(spacingElm)
                elm.children[assessmentIndex].appendChild(textElm)
            })
    
            console.log(`Assessment ${assessmentIndex}: ${assessment.map((number, numberIndex) => {
                return `${foo[numberIndex]}: ${Math.round(number)}`
            }).join('|')}`)
        })
    }
}

/**
 * Estimate a rank percentile in exact form & range.
 * @param {[number, number, number, number, number]} quartiles The 5-figure summary in an array, all from 0-100.
 * @param {number} mark The mark to estimate a rank for
 * @returns {[number, number, number]} The percentile(0-100) and the quartile range(0-4) from/to
 */
function estimateRanking(quartiles, mark) {
    // Find out quarter
    let rangeFrom = 0
    let rangeTo = 0
    for (let i = 0; i <= 4; i++) {
        if (mark < quartiles[i + 1]) { //Mark is within the range
            rangeFrom = i
            rangeTo = i + 1
            break
        } else if (mark == quartiles[i]) { //Mark is the range
            rangeFrom = i
            rangeTo = i
            break
        } else continue
    }

    // If mark is the range, return the quartile
    if(rangeFrom === rangeTo) {
        return [25 * rangeFrom, rangeFrom, rangeTo]
    }

    //Find out rank
    const totalMarkInRange = quartiles[rangeTo] - quartiles[rangeFrom]
    const currentMarkInRange = mark - quartiles[rangeFrom]

    return [(25 * (rangeFrom + (currentMarkInRange / totalMarkInRange))).toFixed(2), rangeFrom, rangeTo]
}